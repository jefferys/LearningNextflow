---
output: html_document
---
# Nextflow HelloWorld

[Assumes have nextflow installed locally where running]

## Running the HelloWorld Nextflow script

### Just run it blindly

This is to see if I can get anything running in nextflow.

Looking at the [HelloWorld Script](https://www.nextflow.io/docs/latest/getstarted.html#your-first-script) from the Nextflow documentation, saved here as HelloWorld/s.nf

```
> nextflow run helloWorld.nf

N E X T F L O W  ~  version 19.10.0
Launching `helloWorld.nf` [mighty_roentgen] - revision: e3b475a61b
executor >  local (3)
[73/74b1c3] process > splitLetters       [100%] 1 of 1 ✔
[74/33edbf] process > convertToUpper (2) [100%] 2 of 2 ✔
HELLO
WORLD!
```

OK, I can run a workflow.

### What did it do?

It output to the command line information about how it ran, and then the STDOUT from the workflow. It also wrote stuff to the file system in the run directory. All of this has hash/unique id's that come from somewhere, so running multiple times creates lots of different stuff.

#### STDOUT from nextflow

Going line by line


* **`N E X T F L O W  ~  version 19.10.0`**

    This is just the version of nextflow being run. Any way to specify this? Yes. See [Running a specific version of nextflow]

* **`Launching `helloWorld.nf` [mighty_roentgen] - revision: e3b475a61b`**

    Gives the nextflow script being run, a name for it, and a revision id for it. The name in [] can be set via a command line parameter for nextflow, `-name <NAME>`. Note that the long options annoyingly take single dashes!
    
    
    ```
    $ mkdir run2
    $ cd run2
    $ nextflow run -name run2 ../helloWorld.nf
    N E X T F L O W  ~  version 19.10.0
    Launching `../helloWorld.nf` [run2] - revision: aeb5c6be25
    executor >  local (2)
    ...
    ```

* **`executor >  local (2)`**

    This describes the execution engine that is running the processes in the script. Since none were specified on the command line, it is running with the default `local` executor. That mean s it just runs locally on the same machine that the terminal is running on. It also specifies the total number of processes run. Some processes may run more than once and that will be reflected in the count live as they are started (not finished)!

* **`[73/74b1c3] process > splitLetters       [100%] 1 of 1 ✔`**  
**`[74/33edbf] process > convertToUpper (2) [100%] 2 of 2 ✔`**

    Another live updating line, this gives the unique id of the latest run of the process (started), which matches the directory associated with that process run. Here work/73/74b1c3* is the directory (the actual directory has a longer hash name). The contents of this directory are any files generated by the process during its run, plus a collection of run-time generated file containing things like STDOUT and STDERR from the process, its exit code, etc. This will be covered in [File System], below.

    The rest of the line live updates as completes. The `[###%] starts out at 0% and becomes 100% when done. It specifies what percent of the number of process runs started have completed The `1 of 1` lists how many instances of a process have been completed, out of how many started. The final check shows up after no more remain to complete. [TODO: Does this also imply no more remain to be started?] testing this is possible by writing the output to a file and seeing the iterative updates.

    ```
    $ cp helloWorld.nf helloWorld3.nf
    $ vi helloWorld3.nf
    # Add a sleep 2 line to the beginning and ending of the two processes' scripts.
    
    $ mkdir run3
    $ cd run3
    $ echo 'params.str = "Hello hello world!"' > nextflow.config
    $ nextflow run -name run3 ../helloWorld3.nf > run.txt
    ```
    
    This results in an output file that looks like:
    
    ```
    N E X T F L O W  ~  version 19.10.0
    Launching `../helloWorld3.nf` [run3.1] - revision: be03ef1dc8
    [-        ] process > splitLetters -
    
    [-        ] process > splitLetters   -
    [-        ] process > convertToUpper -
    
    executor >  local (1)
    [f9/b0d8b9] process > splitLetters   [  0%] 0 of 1
    [-        ] process > convertToUpper -
    
    executor >  local (1)
    [f9/b0d8b9] process > splitLetters   [100%] 1 of 1 ✔
    [-        ] process > convertToUpper -
    
    executor >  local (3)
    [f9/b0d8b9] process > splitLetters       [100%] 1 of 1 ✔
    [1b/94046d] process > convertToUpper (3) [  0%] 0 of 2
    
    executor >  local (4)
    [f9/b0d8b9] process > splitLetters       [100%] 1 of 1 ✔
    [a6/7ead48] process > convertToUpper (2) [  0%] 0 of 3
    
    executor >  local (4)
    [f9/b0d8b9] process > splitLetters       [100%] 1 of 1 ✔
    [70/87d4b7] process > convertToUpper (1) [ 33%] 1 of 3
    HELLO
    
    executor >  local (4)
    [f9/b0d8b9] process > splitLetters       [100%] 1 of 1 ✔
    [1b/94046d] process > convertToUpper (3) [ 67%] 2 of 3
    HELLO
    WORLD!
    
    executor >  local (4)
    [f9/b0d8b9] process > splitLetters       [100%] 1 of 1 ✔
    [a6/7ead48] process > convertToUpper (2) [100%] 3 of 3 ✔
    HELLO
    WORLD!
    HELLO
    ```

* **`HELLO`**  
**`WORLD!`**

    This is just the output from the final step in the script, after the processes, that prints the result.

##### Running a specific version of nextflow

You can specify the version to run via an environmental variable; either set generally to lock the version run, or locally to run a specific version. Due to the zero-config install, if you specify a version that doesn't exist, it will download and install that version to run. This should not affect any existing install due to the java "capsule" installation method used.

From the [FAQ](https://www.nextflow.io/docs/latest/faq.html#how-do-i-use-a-specific-version-of-nextflow):

```
NXF_VER=19.10.0 nextflow run ../helloWorld.nf
```

#### File System

Looking at the file system in one of the run directories indicates three things - a work directory, but also a hidden .nextflow directory and hidden .nextflow.log* files

```
$ ls -al
total 76
drwxr-xr-x.  4 srj shiny 4096 Feb  1 21:15 .
drwxr-xr-x.  5 srj shiny 4096 Feb  1 21:26 ..
drwxr-xr-x.  3 srj shiny 4096 Feb  1 21:15 .nextflow
-rw-r--r--.  1 srj shiny 5023 Feb  1 21:15 .nextflow.log
-rw-r--r--.  1 srj shiny 5685 Feb  1 21:11 .nextflow.log.1
-rw-r--r--.  1 srj shiny 5687 Feb  1 21:06 .nextflow.log.2
-rw-r--r--.  1 srj shiny 6617 Feb  1 21:04 .nextflow.log.3
-rw-r--r--.  1 srj shiny 7552 Feb  1 21:02 .nextflow.log.4
-rw-r--r--.  1 srj shiny 7247 Feb  1 20:57 .nextflow.log.5
-rw-r--r--.  1 srj shiny 6282 Feb  1 20:54 .nextflow.log.6
-rw-r--r--.  1 srj shiny  734 Feb  1 20:52 .nextflow.log.7
drwxr-xr-x. 26 srj shiny 4096 Feb  1 21:15 work
```

* **`.nextflow.log*`**

    A hidden `.nextflow.log*` files seem to be created and rotated with every run. Every one get renamed to a higher number, the newest is always just .nextflow.log
    
    Contents of a `.nextflow.log` looks something like:
    
    ```
    Feb-01 16:06:29.819 [main] DEBUG nextflow.cli.Launcher - $> nextflow run ../helloWorld.nf
    Feb-01 16:06:30.806 [main] INFO  nextflow.cli.CmdRun - N E X T F L O W  ~  version 19.10.0
    Feb-01 16:06:30.909 [main] INFO  nextflow.cli.CmdRun - Launching `../helloWorld.nf` [pedantic_hypatia] - revision: e3b475a61b
    Feb-01 16:06:31.111 [main] DEBUG nextflow.config.ConfigBuilder - Found config home: /home/srj/.nextflow/config
    Feb-01 16:06:31.112 [main] DEBUG nextflow.config.ConfigBuilder - Parsing config file: /home/srj/.nextflow/config
    Feb-01 16:06:31.402 [main] DEBUG nextflow.config.ConfigBuilder - Applying config profile: `standard`
    ...
    ```
    
    All kinds of details about what is being done are recorded here. Probably want to archive this with the processed data for reproducibility.

* **`.nextflow/`**

    ```
    $ ls -al
    drwxr-xr-x. 3 srj shiny 4096 Feb  2 22:19 .
    drwxr-xr-x. 4 srj shiny 4096 Feb  2 21:44 ..
    drwxr-xr-x. 4 srj shiny 4096 Feb  2 21:44 cache
    -rw-r--r--. 1 srj shiny  296 Feb  2 21:44 history
    ```
    
    This hidden directory looks like part of the provenance system for nextflow. It contains a `history` file and a `cache/` directory.

* **`.nextflow/history`**
    
    The `history` file looks like it has one entry for every run, with a couple of uids to track the run and I think the version of the script run. It also lists timing and success info. This is potentially useful information
    
    ```
    2020-02-02 16:41:27     18.1s   run3    OK      be03ef1dc846b92e37c1d1a118ea0d53        6ba44044-4f7e-4575-b2e7-955964192d24    nextflow run -name run3 ../helloWorld3.nf
    2020-02-02 16:44:27     17.7s   run3.1  OK      be03ef1dc846b92e37c1d1a118ea0d53        a3efe8c2-a5b7-433c-990d-aa8aed96065a    nextflow run -name run3.1 ../helloWorld3.nf
    (nextflow) [srj@41df5d809a4c .nextflow]$
    ```

* **`.nextflow/cache/`**

    ```
    $ cd cache; ls -al
    drwxr-xr-x. 4 srj shiny 4096 Feb  2 21:44 .
    drwxr-xr-x. 3 srj shiny 4096 Feb  2 22:19 ..
    drwxr-xr-x. 3 srj shiny 4096 Feb  2 21:41 6ba44044-4f7e-4575-b2e7-955964192d24
    drwxr-xr-x. 3 srj shiny 4096 Feb  2 21:44 a3efe8c2-a5b7-433c-990d-aa8aed96065a
    ```
    
    The `cache/` directory contains one subdirectory for each run. As shown from here down, this looks mostly like internals that are not to useful to be able to mess with independently of the nextflow framework, except they might provide more reproducibility details if needed.

* **`.nextflow/cache/6ba44044-4f7e-4575-b2e7-955964192d24/`**

    ```
    $ cd 6ba44044-4f7e-4575-b2e7-955964192d24; ls -al
    drwxr-xr-x. 3 srj shiny 4096 Feb  2 21:41 .
    drwxr-xr-x. 4 srj shiny 4096 Feb  2 21:44 ..
    drwxr-xr-x. 2 srj shiny 4096 Feb  2 21:41 db
    -rw-r--r--. 1 srj shiny   68 Feb  2 21:41 index.run3
    ```
    
    The contents of this look like an internal database for storing information about each workflow run. It has a `db/` directory and an `index` file named for the run.

* **`.nextflow/cache/<uid>/index`**

    The `index` file contains a small amount of binary with little readable text.

* **`.nextflow/cache/<uid>/db/`**

    ```
    $ cd db; ls -al
    drwxr-xr-x. 2 srj shiny 4096 Feb  2 21:41 .
    drwxr-xr-x. 3 srj shiny 4096 Feb  2 21:41 ..
    -rw-r--r--. 1 srj shiny 2592 Feb  2 21:41 000003.log
    -rw-r--r--. 1 srj shiny   16 Feb  2 21:41 CURRENT
    -rw-r--r--. 1 srj shiny    0 Feb  2 21:41 LOCK
    -rw-r--r--. 1 srj shiny   50 Feb  2 21:41 MANIFEST-000002
    ```
    
    The db contains what looks like concurrency management files in terms of a `LOCK` file (empty here) and a `CURRENT` file that contains the name of the `MANIFEST-000002` file. The `MANIFEST-000002` file has a tiny bit of binary that looks like it names a Java class, `leveldb.BytewiseComparator`. This has something to do with a java implementation of the "leveldb" database. There is also a `000003.log` file that also contains binary but with a lot o readable text; it looks like it contains details on each process as it runs, including what looks like the entire script text, for each process instance, but with variables and temporary locations explicitly described.
    
    Not sure what any of the numbers mean in these titles.

* **`work/**`

    Contents of the work directory are subdirectories named for process runs. For example, the run above created a process
    
    ```
    [d1/7cabb8] process > splitLetters       [100%] 1 of 1 ✔
    ```
    
    and this is  associated with the existence of a directory
    
    ```
    work/
        f9/
            b0d8b946fbf744a827
    ```
    
    The directories are not all described in the text output from the nextflow run. There is one directory per process run, but only one line per process is displayed, it live updates and over-write each process line with the latest run of that process.
    
    These directories contain files output by a process run, links to files input (staged input files), and additional files describing the elements of the process run.

* **`work/f9/b0d8b946fbf744a827961490dbb2a9/**`

    ```
    $ ls -al
    lrwxrwxrwx. 1 srj shiny  106 Feb  2 21:44 chunk_ac -> /path/to/HelloWorld/work/f9/b0d8b946fbf744a827961490dbb2a9/chunk_ac
    -rw-r--r--. 1 srj shiny    0 Feb  2 21:44 .command.begin
    -rw-r--r--. 1 srj shiny    0 Feb  2 21:44 .command.err
    -rw-r--r--. 1 srj shiny    6 Feb  2 21:44 .command.log
    -rw-r--r--. 1 srj shiny    6 Feb  2 21:44 .command.out
    -rw-r--r--. 1 srj shiny 2501 Feb  2 21:44 .command.run
    -rw-r--r--. 1 srj shiny   66 Feb  2 21:44 .command.sh
    -rw-r--r--. 1 srj shiny    1 Feb  2 21:44 .exitcode
```

* **`work/<run_id_dirs>/.command.begin`**

    TODO: Seems to be a flag file that processing of this step has begun.
    
* **`work/<run_id_dirs>/.command.err`**

    The text sent to STDERR during this process run

* **`work/<run_id_dirs>/.command.log`**

    TODO: Not sure what this is. Here this is equal to .command.out

* **`work/<run_id_dirs>/.command.out`**

    The text sent to STDOUT during this process run

* **`work/<run_id_dirs>/.command.run`**

    The executor script that executes the step script, `.command.sh`. It is likely very specific to the executor. The script from the step is executed when `nxf_launch` is called from `nxf_main`. This script uses a clever mechanism to be testable and generic; it is essentially all function declarations except for the internal variable `NXF_ENTRY`. This is executed as the last line in the script, so it can be set to any function and that will be what the script runs. At the top of the script, this is set to either `$1`, or by default to the "main" function, `nxf_main`, so just running this script with no parameters runs the main function, running with a function name runs the function specified. This may be needed for more than testing with other executors; this lets the script contain functions that define takes to be executed remotely, e.g. on a cluster.

    ```
    #!/bin/bash
    # NEXTFLOW TASK: convertToUpper (3)
    set -e
    set -u
    NXF_DEBUG=${NXF_DEBUG:=0}; [[ $NXF_DEBUG > 1 ]] && set -x
    NXF_ENTRY=${1:-nxf_main}
    
    
    nxf_date() {
        local ts=$(date +%s%3N); [[ $ts == *3N ]] && date +%s000 || echo $ts
    }
    
    nxf_env() {
        echo '============= task environment ============='
        env | sort | sed "s/\(.*\)AWS\(.*\)=\(.\{6\}\).*/\1AWS\2=\3xxxxxxxxxxxxx/"
        echo '============= task output =================='
    }
    
    nxf_kill() {
        declare -a children
        while read P PP;do
            children[$PP]+=" $P"
        done < <(ps -e -o pid= -o ppid=)
    
        kill_all() {
            [[ $1 != $$ ]] && kill $1 2>/dev/null || true
            for i in ${children[$1]:=}; do kill_all $i; done
        }
    
        kill_all $1
    }
    
    nxf_mktemp() {
        local base=${1:-/tmp}
        if [[ $(uname) = Darwin ]]; then mktemp -d $base/nxf.XXXXXXXXXX
        else TMPDIR="$base" mktemp -d -t nxf.XXXXXXXXXX
        fi
    }
    
    on_exit() {
        exit_status=${nxf_main_ret:=$?}
        printf $exit_status > /home/srj/GitHub/Jefferys/LearningNextflow/HelloWorld/run3/work/1b/94046dd627630e703983bd9273b2f8/.exitcode
        set +u
        [[ "$tee1" ]] && kill $tee1 2>/dev/null
        [[ "$tee2" ]] && kill $tee2 2>/dev/null
        [[ "$ctmp" ]] && rm -rf $ctmp || true
        exit $exit_status
    }
    
    on_term() {
        set +e
        [[ "$pid" ]] && nxf_kill $pid
    }
    
    nxf_launch() {
        /bin/bash -ue /home/srj/GitHub/Jefferys/LearningNextflow/HelloWorld/run3/work/1b/94046dd627630e703983bd9273b2f8/.command.sh
    }
    
    nxf_stage() {
        true
        # stage input files
        rm -f chunk_ac
        ln -s /home/srj/GitHub/Jefferys/LearningNextflow/HelloWorld/run3/work/f9/b0d8b946fbf744a827961490dbb2a9/chunk_ac chunk_ac
    }
    
    nxf_unstage() {
        true
        [[ ${nxf_main_ret:=0} != 0 ]] && return
    }
    
    nxf_main() {
        trap on_exit EXIT
        trap on_term TERM INT USR1 USR2
    
        NXF_SCRATCH=''
        [[ $NXF_DEBUG > 0 ]] && nxf_env
        touch /home/srj/GitHub/Jefferys/LearningNextflow/HelloWorld/run3/work/1b/94046dd627630e703983bd9273b2f8/.command.begin
        set +u
        set -u
        [[ $NXF_SCRATCH ]] && echo "nxf-scratch-dir $HOSTNAME:$NXF_SCRATCH" && cd $NXF_SCRATCH
        nxf_stage
    
        set +e
        local ctmp=$(set +u; nxf_mktemp /dev/shm 2>/dev/null || nxf_mktemp $TMPDIR)
        local cout=$ctmp/.command.out; mkfifo $cout
        local cerr=$ctmp/.command.err; mkfifo $cerr
        tee .command.out < $cout &
        tee1=$!
        tee .command.err < $cerr >&2 &
        tee2=$!
        ( nxf_launch ) >$cout 2>$cerr &
        pid=$!
        wait $pid || nxf_main_ret=$?
        wait $tee1 $tee2
        nxf_unstage
    }
    
    $NXF_ENTRY
    ```

* **`work/<run_id_dirs>/.command.sh`**

    A runnable copy of the script component of this process, with parameters replaced and a shebang line added. Initially (in the process in the workflow) the script was:
    
    ```
    sleep 2
    cat $x | tr '[a-z]' '[A-Z]'
    sleep 2
    ```
    
        The runnable version recorded as `.command.sh` is
        
    ```
    #!/bin/bash -ue
    sleep 2
    cat chunk_ac | tr '[a-z]' '[A-Z]'
    sleep 2
    ```
    
        TODO: Where does the shebang line come from? Is this specific to the executor?
    
* **`work/<run_id_dirs>/.exitcode`**

    The exit code from the script run by this process.

    

Not sure how dependent of the executor this all is

## The params object and configuration files

TODO: Make Config a separate chapter!

Data can be passed around via the parameters object. The main use seems to be to pass data from a configuration file into the nextflow run. Multiple config files can be specified. Merging combines each file found by the file search and each on top of previous information.

More details on configuration files can be found [here](https://www.nextflow.io/docs/latest/config.html)

### Configuration files search paths

The seqarch path finds files and loads parameter data in the following order (overwritting existing data each time if needed):
    * Default `params.*` values as specified in the nextflow script
    * Nextflow config for the user, from: `$HOME/.nextflow/config`
    * Nextflow config for the workflow (base directory of workflow) `<base>/nextflow.config`
    * Nextflow config for the run (current directory) `./nextflow.config`
    * Nextflow config file specified on the command line as `-c <filename>`
    
Many things can go in config files. Lets start with just setting values that can be accessed by a running workflow script, These are `params.*` values. The `params.` part is called the scope of the variable, `*`. There are other scopes; we will worry about that later.

### Testing config file paths

#### Default + Run config

Create nextflow.config file in base HelloWorld directory alongside helloWorld.nf

```
$ echo 'params.str = "Hello hello world!"' > nextflow.config
$ nextflow run helloWorld.nf

N E X T F L O W  ~  version 19.10.0
Launching `helloWorld.nf` [intergalactic_picasso] - revision: e3b475a61b
executor >  local (4)
[d1/7cabb8] process > splitLetters       [100%] 1 of 1 ✔
[60/a2c1f5] process > convertToUpper (3) [100%] 3 of 3 ✔
HELLO
HELLO
WORLD!
```

OK, that worked. The local script specification of params.str was over-ridden too.

#### Default + workflow config

Lets create a run directory and try from there

```
$ mkdir run1
$ cd run1
$ nextflow run helloWorld.nf

N E X T F L O W  ~  version 19.10.0
Not a valid project name: helloWorld.nf
```

Oops, didn't point to the workflow. Lets try again.

```
$ nextflow run ../helloWorld.nf

N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [wise_euler] - revision: e3b475a61b
executor >  local (4)
[a7/a3d5d5] process > splitLetters       [100%] 1 of 1 ✔
[af/27db84] process > convertToUpper (2) [100%] 3 of 3 ✔
HELLO
WORLD!
HELLO
```

OK, that found the "workflow" config file in the same directory as the workflow.

#### Default + workflow + run config

Now lets see if a local one overrides that as it says it should

```
$ echo 'params.str = "Hello hello hello world!"' > nextflow.config
$ nextflow run ../helloWorld.nf

N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [stupefied_varahamihira] - revision: e3b475a61b
executor >  local (5)
[ff/6be7ff] process > splitLetters       [100%] 1 of 1 ✔
[06/7620bc] process > convertToUpper (3) [100%] 4 of 4 ✔
HELLO
WORLD!
HELLO
HELLO
```

Yay. local overrides workflow.

#### Default + workflow + run config + -c config

Now lets see if a command line one overrides that as it says it should

```
$ echo 'params.str = "Hello hello hello hello world!"' > my.config
$ nextflow run ../helloWorld.nf -c my.config

N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [jolly_monod] - revision: e3b475a61b
executor >  local (6)
[f0/fe8543] process > splitLetters       [100%] 1 of 1 ✔
[e2/a2dc6b] process > convertToUpper (2) [100%] 5 of 5 ✔
HELLO
HELLO
HELLO
WORLD!
HELLO
```

Specific works to override local.

#### User config file

Lets try the user version

```
$ echo $HOME
/home/srj

$ echo 'params.str = "Hello Stuart"' > $HOME/.nextflow/config

# Default + user + workflow + run configs
# Controlled by local/run config
$ nextflow run ../helloWorld.nf
N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [evil_ekeblad] - revision: e3b475a61b
executor >  local (5)
[f7/fcb91f] process > splitLetters       [100%] 1 of 1 ✔
[bf/569f03] process > convertToUpper (4) [100%] 4 of 4 ✔
HELLO
HELLO
HELLO
WORLD!
```

```
$ rm nextflow.config

# Default + user + workflow
# Controlled by workflow config
$ nextflow run ../helloWorld.nf
N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [serene_einstein] - revision: e3b475a61b
executor >  local (4)
[09/e6cc7c] process > splitLetters       [100%] 1 of 1 ✔
[cb/3689a2] process > convertToUpper (3) [100%] 3 of 3 ✔
HELLO
HELLO
WORLD!

$ rm ../nextflow.config

# Default + user
# Controlled  by user config
$ nextflow run ../helloWorld.nf
N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [pedantic_hypatia] - revision: e3b475a61b
executor >  local (3)
[94/023df5] process > splitLetters       [100%] 1 of 1 ✔
[a8/697706] process > convertToUpper (2) [100%] 2 of 2 ✔
HELLO
STUART
```

What happens if it doesn't have the params line in the script but does have it in the config file?

```
$ vi ../helloWorld.nf
# comment out the params.str line with //

# user conig only, no default
$ nextflow run ../helloWorld.nf
N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [prickly_agnesi] - revision: aeb5c6be25
executor >  local (3)
[ab/ed914f] process > splitLetters       [100%] 1 of 1 ✔
[88/3d86aa] process > convertToUpper (2) [100%] 2 of 2 ✔
HELLO
STUART
```

OK. Now what happens if its not even in the config file? This should be an unspecified parameter error, unless they are automatically initialized to something.

```
$ rm $HOME/.nextflow/config
$ nextflow run ../helloWorld.nf
N E X T F L O W  ~  version 19.10.0
Launching `../helloWorld.nf` [extravagant_jang] - revision: aeb5c6be25
executor >  local (2)
[bb/d71b27] process > splitLetters       [100%] 1 of 1 ✔
[13/2305f7] process > convertToUpper (1) [100%] 1 of 1 ✔
NULL
WARN: Access to undefined parameter `str` -- Initialise it to a default value eg. `params.str = some_value`
```

Nice. Does default initialize, but warns about the missing thing too!

#### One and only config file `-C <file>`

If a capital -C is used to specify a config file, that means use this config file and no other. Have to change to the code a bit to test this, will add multiple params. Have to have one variable per config file to see if each is being read. 

TODO:: Set this up
TODO:: Try with -c and -C to see what happens

## Notes

### Best practice

* Provide useful defaults whenever possible. Since a Nextflow script is really a groovy script, can use code to guess if no natural default.

### Key points

* Nextflow workflow scripts are basically groovy scripts with additional language elements added.
* Nextflow workflows are composed of processes that are steps in a workflow.
* Process steps are connected by channels. A parent process has an output channel that is used as the input channel of a child process.
* The order in which process steps are executed is based only on when data becomes available; each step runs as soon as it can, based on the data it needs being available on its input channel.
* Process steps are executed in isolation by a chosen executor. Ideally, different executors allow the same workflow to be run in different locations - e.g. locally or on a Slurm cluster or in Google cloud. [SRJ: Is this true? I'm guessing that this is supposed to be a goal.]
    
    